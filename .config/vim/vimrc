if &encoding !=? 'utf-8'
  let &termencoding = &encoding
  set encoding=utf-8
endif

scriptencoding utf-8

if has('guess_encode')
  set fileencodings=ucs-bom,utf-8,iso-2022-jp,guess,euc-jp,cp932,latin1
else
  set fileencodings=ucs-bom,utf-8,iso-2022-jp,euc-jp,cp932,latin1
endif
set fileformats=unix,dos


" dein.vim
let s:dein_dir = expand('$XDG_DATA_HOME/dein')
let s:dein_repo_dir = s:dein_dir .. '/repos/github.com/Shougo/dein.vim'

" clone dein.vim when not having installed dein.vim
if &runtimepath !~# '/dein.vim'
  if !isdirectory(s:dein_repo_dir)
    execute '!git clone https://github.com/Shougo/dein.vim' s:dein_repo_dir
  endif
  execute 'set runtimepath^=' .. fnamemodify(s:dein_repo_dir, ':p')
endif

if dein#load_state(s:dein_dir)
  call dein#begin(s:dein_dir)
  " Set directories for dein.toml and dein_lazy.toml
  let s:toml_dir = expand('$XDG_CONFIG_HOME/vim/rc')
  call dein#load_toml(s:toml_dir .. '/dein.toml', {'lazy': 0})
  call dein#load_toml(s:toml_dir .. '/dein_lazy.toml', {'lazy': 1})
  call dein#end()
  call dein#save_state()
endif

filetype plugin indent on
syntax enable

" If you want to install not installed plugins on startup.
if dein#check_install()
  call dein#install()
endif


" ddc.vim
call ddc#custom#patch_global('ui', 'native')
call ddc#custom#patch_global('sources', [
  \   'around', 'buffer', 'file', 'skkeleton', 'vim-lsp'
  \ ])
call ddc#custom#patch_global('sourceOptions', {
  \   'around': {'mark': 'arnd'},
  \   'buffer': {'mark': 'buf'},
  \   'file': {
  \     'mark': 'file',
  \     'isVolatile': v:true,
  \     'forceCompletionPattern': '\S/\S*',
  \   },
  \   'skkeleton': {
  \     'mark': 'skk',
  \     'matchers': ['skkeleton'],
  \     'sorters': [],
  \     'minAutoCompleteLength': 2,
  \     'isVolatile': v:true,
  \   },
  \   'vim-lsp': {'mark': 'lsp'},
  \   '_': {
  \     'matchers': ['matcher_fuzzy', 'matcher_head'],
  \     'sorters': ['sorter_fuzzy'],
  \     'converters': ['converter_fuzzy'],
  \   },
  \ })

call ddc#custom#patch_global('sourceParams', {
  \   'around': {'maxSize': 500},
  \   'buffer': {
  \     'requireSameFiletype': v:false,
  \     'limitBytes': 5000000,
  \     'fromAltBuf': v:true,
  \     'forceCollect': v:true,
  \   },
  \ })

call ddc#custom#patch_filetype(['ps1', 'dosbatch', 'autohotkey', 'registry'], {
  \   'sourceOptions': {
  \     'file': {
  \       'forceCompletionPattern': '\S\\\S*',
  \     },
  \   },
  \   'sourceParams': {
  \     'file': {
  \       'mode': 'win32',
  \     },
  \   },
  \ })

call ddc#enable()


" ddu.vim
call ddu#custom#patch_global({
  \   'ui': 'filer',
  \   'sources': [{'name': 'file', 'params': {}}],
  \   'actionOptions': {
  \     'narrow': {
  \       'quit': v:false,
  \     },
  \   },
  \   'sourceOptions': {
  \     '_': {
  \       'columns': ['filename'],
  \     },
  \   },
  \   'kindOptions': {
  \     'file': {
  \       'defaultAction': 'open',
  \     },
  \   },
  \ })

autocmd FileType ddu-filer call s:ddu_my_settings()
function! s:ddu_my_settings() abort
  nnoremap <buffer><silent> <CR>
    \   :call ddu#ui#filer#do_action('itemAction')<CR>
  nnoremap <buffer><silent> <Space>
    \   :call ddu#ui#filer#do_action('toggleSelectItem')<CR>
  nnoremap <buffer> o
    \   :call ddu#ui#filer#do_action('expandItem', {'mode': 'toggle'})<CR>
  nnoremap <buffer><silent> q
    \   :call ddu#ui#filer#do_action('quit')<CR>
endfunction


let g:mapleader = "\<Space>"

colorscheme desert
set ruler
set showcmd
set shortmess=filmnxtToOc
set smartindent
set display=lastline
set backspace=indent,eol,start
set nofixeol
set ignorecase
set smartcase
set tabpagemax=255
set whichwrap=b,s,h,l,<,>,[,]
set number
set list
set listchars=tab:>-,extends:<,trail:-
set hlsearch
set incsearch
set expandtab
set shiftwidth=2
set matchpairs+=<:>,「:」,（:）,『:』,【:】,《:》,〈:〉,｛:｝,［:］,【:】,‘:’,“:”
set autochdir
set spell
set spelllang& spelllang+=cjk
set spelloptions& spelloptions+=camel
set formatoptions+=M
set nrformats+=unsigned
set scrolloff=5
set viminfofile=$XDG_DATA_HOME/vim/viminfo
set viminfo='1000,f1,<500,s10,h
set updatetime=1500
set splitright
set showtabline=2
set shell=/bin/bash

augroup Go
  autocmd!
  autocmd Filetype go setlocal noexpandtab
  autocmd Filetype go setlocal shiftwidth=4
  autocmd Filetype go setlocal tabstop=4
  autocmd Filetype go setlocal listchars=tab:\ \ ,extends:<,trail:-
augroup END

nnoremap <leader>s <Cmd>setlocal spell! spell?<CR>
nnoremap <leader>h <C-6>
nnoremap <leader>F <Cmd>call ddu#start({})<CR>
nnoremap <leader>D <Cmd>call dein#update()<CR>
nnoremap <leader>R <Cmd>call dein#recache_runtimepath()<CR>
" nnoremap <leader>U <Cmd>call dein#update('skkeleton')<CR>
nnoremap <leader>f <Cmd>Files<CR>
nnoremap <leader>sr <Plug>(shakyo-run)
nnoremap <leader>sc <Plug>(shakyo-clue)
nnoremap <leader>sq <Plug>(shakyo-quit)
nnoremap <leader>sf <Plug>(shakyo-force-quit)
nnoremap <leader>su <Cmd>call dein#update('vim-shakyo')<CR>
nnoremap <silent> <leader>q <Plug>(socrates-greed)
nnoremap <leader>m <Plug>(MatchitNormalForward)
vnoremap <leader>m <Plug>(MatchitVisualForward)

" QuickFix
autocmd QuickFixCmdPost *grep* cwindow
nnoremap [N <Cmd>cprevious<CR>
nnoremap [n <Cmd>cnext<CR>
nnoremap [i <Cmd>cfirst<CR>
nnoremap [a <Cmd>clast<CR>

" vim-sandwich
let g:sandwich_no_default_key_mappings = 1
nnoremap <leader>a  <Plug>(sandwich-add)
xnoremap <leader>a  <Plug>(sandwich-add)
onoremap <leader>a  <Plug>(sandwich-add)
nnoremap <leader>d  <Plug>(sandwich-delete)
xnoremap <leader>d  <Plug>(sandwich-delete)
nnoremap <leader>db <Plug>(sandwich-delete-auto)
nnoremap <leader>r  <Plug>(sandwich-replace)
xnoremap <leader>r  <Plug>(sandwich-replace)
nnoremap <leader>rb <Plug>(sandwich-replace-auto)

digraphs j( 65288 " （
digraphs j) 65289 " ）
digraphs j[ 12300 " 「
digraphs j] 12301 " 」
digraphs j{ 12302 " 『
digraphs j} 12303 " 』
digraphs j< 12304 " 【
digraphs j> 12305 " 】
digraphs j, 12289 " 、
digraphs j. 12290 " 。
digraphs j! 65281 " ！
digraphs j? 65311 " ？
digraphs j: 65306 " ：
digraphs j0 65296 " ０
digraphs j1 65297 " １
digraphs j2 65298 " ２
digraphs j3 65299 " ３
digraphs j4 65300 " ４
digraphs j5 65301 " ５
digraphs j6 65302 " ６
digraphs j7 65303 " ７
digraphs j8 65304 " ８
digraphs j9 65305 " ９
digraphs j~ 12316 " 〜
digraphs j/ 12539 " ・
digraphs js 12288 " 　

noremap fj f<C-k>j
noremap Fj F<C-k>j
noremap tj t<C-k>j
noremap Tj T<C-k>j

runtime ftplugin/man.vim

inoremap jj <ESC>
cnoremap jj <ESC>

" For CSI u mode
inoremap <S-Space> <Space>
cnoremap <S-Space> <Space>
noremap <C-I> <C-I>
noremap <Tab>     :tabnext<CR><C-G>
noremap <S-Tab>   :tabprevious<CR><C-G>

let g:most_recently_closed = []
augroup MostRecentlyClosedTabs
  autocmd!
  autocmd BufWinLeave * call insert(g:most_recently_closed, expand('<amatch>'))
augroup END

noremap <C-Right>  :tabnext<CR><C-G>
noremap <C-Left>   :tabprevious<CR><C-G>
noremap <C-Up>     :if len(g:most_recently_closed) > 0 \|
                     \   execute ':tabnew ' .. remove(g:most_recently_closed, 0) \|
                     \ endif<CR>
noremap  <C-Down>  :q<CR><C-G>
noremap  <expr> <C-lt> ':tabmove -' .. v:count1 .. '<CR>'
noremap  <expr> <C->>  ':tabmove +' .. v:count1 .. '<CR>'
nnoremap gr        <Cmd>tabnext<CR><C-G>
nnoremap gR        <Cmd>tabprevious<CR><C-G>
" nnoremap q:        <Cmd>q<CR><C-G>
tnoremap <C-Right> <Cmd>tabnext<CR><C-G>
tnoremap <C-Left>  <Cmd>tabprevious<CR><C-G>
tnoremap <C-Down>  <Cmd>q<CR><C-G>

nnoremap <C-L> <Cmd>nohlsearch<CR><C-L>
nnoremap * *``zz
nnoremap # #``zz

noremap <expr> j v:count == 0 ? 'gj' : 'm`' .. v:count .. 'gj'
noremap <expr> k v:count == 0 ? 'gk' : 'm`' .. v:count .. 'gk'
noremap gj  j
noremap gk  k
noremap <Up>   gk
noremap <Down> gj
inoremap <Up>   <C-O>gk
inoremap <Down> <C-O>gj

nnoremap gf <C-W><C-F><C-W>T
nnoremap <C-W><C-F> gf

inoremap <Tab>   <C-N>
inoremap <S-Tab> <C-P>

nnoremap <expr> n (v:searchforward ? 'n' : 'N')
nnoremap <expr> N (v:searchforward ? 'N' : 'n')

" Change the size of windows
nnoremap <S-Left>  <C-W><<CR>
nnoremap <S-Right> <C-W>><CR>
nnoremap <S-Up>    <C-W>-<CR>
nnoremap <S-Down>  <C-W>+<CR>

nnoremap x "_x
nnoremap X "_X
nnoremap s "_s

nnoremap Y y$
nnoremap / /\v
nnoremap <C-G>  2<C-G>
nnoremap 2<C-G> <C-G>

nnoremap mk mQ
nnoremap mm `Q

" Change cursors according with mode
let &t_ti .= "\e[1 q"
let &t_SI .= "\e[5 q"
let &t_EI .= "\e[1 q"
let &t_te .= "\e[0 q"

" Enable bracketed-paste
if &term =~ 'screen'
  let &t_BE = "\e[?2004h"
  let &t_BD = "\e[?2004l"
  set t_PS=\e[200~
  set t_PE=\e[201~
endif

" Set the indent inside the p tags
let g:html_indent_inctags = 'p'

" Auto completion to close XML tags
augroup CloseTags
  autocmd!
  autocmd Filetype html,xml inoremap <buffer> </ </<C-X><C-O><C-O><CR><ESC>==o
augroup END

command -nargs=0 ClearUndo call s:ClearUndo()
function! s:ClearUndo()
  let old_undolevels = &undolevels
  set undolevels=-1
  execute "normal! a \<BS>\<Esc>"
  let &undolevels = old_undolevels
  unlet old_undolevels
endfunction


function! s:on_lsp_buffer_enabled() abort
  setlocal omnifunc=lsp#complete
  setlocal signcolumn=yes
  nnoremap <buffer> gd <plug>(lsp-definition)
  nnoremap <buffer> <f2> <plug>(lsp-rename)
  " inoremap <expr> <CR> pumvisible() ? "\<C-Y>\<CR>" : "\<CR>"
endfunction

augroup lsp_install
  autocmd!
  autocmd User lsp_buffer_enabled call s:on_lsp_buffer_enabled()
augroup END

command! LspDebug let lsp_log_verbose=1 | let lsp_log_file = expand('$HOME/lsp.log')
let g:lsp_diagnostics_enabled = 1
let g:lsp_diagnostics_virtual_text_enabled = v:false
let g:lsp_diagnostics_echo_cursor = 1
let g:lsp_text_edit_enabled = 1
let g:lsp_settings_filetype_ruby = 'solargraph'


" Display results on the upper side with denite
let g:fzf_layout = { 'up': '~40%' }

" Search tags with <C-]>
nnoremap <silent> <C-]> <Cmd>call fzf#vim#tags(expand('<cword>'))<CR>

" Make it possible to jump from fzf to the file
let g:fzf_buffers_jump = 1

" Specify a user snippet directory
let g:vsnip_snippet_dir = expand('$XDG_CONFIG_HOME/vsnip')

" Define a skk dictionary
call skkeleton#azik#add_table('us')
call skkeleton#config({
  \   'globalDictionaries': [
  \     [expand('$XDG_DATA_HOME/skk/SKK-JISYO.L'), 'euc-jp'],
  \     [expand('$XDG_DATA_HOME/skk/SKK-JISYO.geo'), 'euc-jp'],
  \     [expand('$XDG_DATA_HOME/skk/SKK-JISYO.jinmei'), 'euc-jp'],
  \     [expand('$XDG_DATA_HOME/skk/SKK-JISYO.propernoun'), 'euc-jp'],
  \     [expand('$XDG_DATA_HOME/skk/SKK-JISYO.station'), 'euc-jp'],
  \     [expand('$XDG_DATA_HOME/skk/SKK-JISYO.emoji.utf8'), 'utf-8'],
  \     [expand('$XDG_DATA_HOME/skk/zipcode/SKK-JISYO.zipcode'), 'euc-jp'],
  \   ],
  \   'kanaTable': 'azik',
  \   'completionRankFile': expand('$XDG_DATA_HOME/skk/rank.json'),
  \   'eggLikeNewline': v:true,
  \   'keepState': v:true,
  \   'markerHenkan': 'γ',
  \   'markerHenkanSelect': 'Γ',
  \   'registerConvertResult': v:true,
  \   'showCandidatesCount': 1,
  \   'selectCandidateKeys': '12345qw',
  \   'userJisyo': expand('$XDG_DATA_HOME/skk/skkeleton'),
  \ })

call skkeleton#register_keymap('input', ';', 'henkanPoint')
call skkeleton#register_keymap('henkan', '<', 'purgeCandidate')
call skkeleton#register_keymap('henkan', 'X', v:false)

let g:skkeleton_state_id = v:null

function! s:skkeleton_state_popup()
  if g:skkeleton_state_id != v:null
    call popup_close(g:skkeleton_state_id)
  endif
  if g:skkeleton#mode != ''
    let g:skkeleton_state_id = popup_create(g:skkeleton#mode, #{pos: 'botleft', line: 'cursor+1', col: 'cursor', moved: 'any', highlight: 'WildMenu'})
  endif
endfunction

function s:mapAzikOkuri(input, feed) abort
  for mode in ['i', 'c']
    execute 'autocmd User skkeleton-enable-post ' .. mode .. 'map <buffer> ' ..
      \   a:input .. " <Cmd>call <SID>azikOkuri('" .. a:input .. "', '" ..
      \   a:feed .. "')<CR>"
    execute 'autocmd User skkeleton-disable-post silent! ' .. mode ..
      \   'unmap <buffer> ' .. a:input
  endfor
endfunction

function s:azikOkuri(input, feed) abort
  if g:skkeleton#state.phase ==# 'input:okurinasi' && g:skkeleton#mode !=# 'abbrev'
    \   && g:skkeleton#vim_status().prevInput =~# '\a$'
    call skkeleton#handle('handleKey', {'key': split(a:feed, '\zs')})
  else
    call skkeleton#handle('handleKey', {'key': a:input})
  endif
endfunction

augroup Skkeleton
  autocmd!
  autocmd User skkeleton-handled call s:skkeleton_state_popup()

  let s:azikOkuriList = [
    \   ['Q', 'aI'],
    \   ['Z', 'aNn'],
    \   ['K', 'iNn'],
    \   ['H', 'uU'],
    \   ['J', 'uNn'],
    \   ['W', 'eI'],
    \   ['D', 'eNn'],
    \   ['P', 'oU'],
    \   ['L', 'oNn'],
    \ ]
  for s:azikOkuriItem in s:azikOkuriList
    call s:mapAzikOkuri(s:azikOkuriItem[0], s:azikOkuriItem[1])
  endfor

  autocmd InsertLeave * if g:skkeleton#state.phase ==# 'henkan' && getline('.') !~ '^\s*$' |
                          \   call job_start(['wl-copy', '--', getline('.')]) |
                          \ endif

  autocmd InsertEnter * ++once call skkeleton#register_kanatable('azik', {
    \   '<s-j><s-j>': ['じゅん', ''],
    \   'jj':    'escape',
    \   '''':    'disable',
    \   '@':     'zenkaku',
    \   'q':     'katakana',
    \   '<s-q>': 'hankatakana',
    \   'z=':    ['＝', ''],
    \   'z~':    ['～', ''],
    \   'z ':    ['　', ''],
    "\   ':':     ['ー', ''],
    \   'z:':    ['：', ''],
    \   'l':     ['っ', ''],
    \   'n':     ['ん', ''],
    \   'n''':   ['ん', ''],
    \   'kyi':   ['きぃ', ''],
    \   'kyk':   ['きん', ''],
    \   'kgi':   ['きぃ', ''],
    \   'kgk':   ['きん', ''],
    \   'gyi':   ['ぎぃ', ''],
    \   'gyk':   ['ぎん', ''],
    \   'xi':    ['し', ''],
    \   'xy':    ['しぃ', ''],
    \   'xk':    ['しん', ''],
    \   'ci':    ['ち', ''],
    \   'cy':    ['ちぃ', ''],
    \   'ck':    ['ちん', ''],
    \   'jk':    ['じん', ''],
    \   'syi':   ['しぃ', ''],
    \   'syk':   ['しん', ''],
    \   'zyi':   ['じぃ', ''],
    \   'zyk':   ['じん', ''],
    \   'tyi':   ['ちぃ', ''],
    \   'tyk':   ['ちん', ''],
    \   'dyi':   ['ぢぃ', ''],
    \   'dyk':   ['ぢん', ''],
    \   'nyi':   ['にぃ', ''],
    \   'nyk':   ['にん', ''],
    \   'ngi':   ['にぃ', ''],
    \   'ngk':   ['にん', ''],
    \   'hyi':   ['ひぃ', ''],
    \   'hyk':   ['ひん', ''],
    \   'hgi':   ['ひぃ', ''],
    \   'hgk':   ['ひん', ''],
    \   'byi':   ['びぃ', ''],
    \   'byk':   ['びん', ''],
    \   'bgi':   ['びぃ', ''],
    \   'bgk':   ['びん', ''],
    \   'pyi':   ['ぴぃ', ''],
    \   'pyk':   ['ぴん', ''],
    \   'pgi':   ['ぴぃ', ''],
    \   'pgk':   ['ぴん', ''],
    \   'myi':   ['みぃ', ''],
    \   'myk':   ['みん', ''],
    \   'mgi':   ['みぃ', ''],
    \   'mgk':   ['みん', ''],
    \   'ryi':   ['りぃ', ''],
    \   'ryk':   ['りん', ''],
    \   'xxa':   ['ぁ', ''],
    \   'xxi':   ['ぃ', ''],
    \   'xxu':   ['ぅ', ''],
    \   'xxe':   ['ぇ', ''],
    \   'xxo':   ['ぉ', ''],
    \   'xxya':  ['ゃ', ''],
    \   'xxyu':  ['ゅ', ''],
    \   'xxyo':  ['ょ', ''],
    \   'xxwa':  ['ゎ', ''],
    \   'tsa':   ['つぁ', ''],
    \   'tsi':   ['つぃ', ''],
    \   'tsu':   ['つ', ''],
    \   'tse':   ['つぇ', ''],
    \   'tso':   ['つぉ', ''],
    \   'tsq':   ['つぁい', ''],
    \   'tsz':   ['つぁん', ''],
    \   'tsk':   ['つぃん', ''],
    \   'tsh':   ['つう', ''],
    \   'tsj':   ['つん', ''],
    \   'tsw':   ['つぇい', ''],
    \   'tsd':   ['つぇん', ''],
    \   'tsp':   ['つぉう', ''],
    \   'tsl':   ['つぉん', ''],
    \   'dya':   ['ぢゃ', ''],
    \   'dyu':   ['ぢゅ', ''],
    \   'dye':   ['ぢぇ', ''],
    \   'dyo':   ['ぢょ', ''],
    \   'dyq':   ['ぢゃい', ''],
    \   'dyz':   ['ぢゃん', ''],
    \   'dyh':   ['ぢゅう', ''],
    \   'dyj':   ['ぢゅん', ''],
    \   'ww':    ['うぇい', ''],
    \   'sm':    ['さま', ''],
    \   'dx':    ['でした', ''],
    \   'mx':    ['ました', ''],
    \   'kf':    ['かい', ''],
    \   'gf':    ['がい', ''],
    \   'gyf':   ['ぎゃい', ''],
    \   'sf':    ['さい', ''],
    \   'zf':    ['ざい', ''],
    \   'xf':    ['しゃい', ''],
    \   'syf':   ['しゃい', ''],
    \   'jf':    ['じゃい', ''],
    \   'zyf':   ['じゃい', ''],
    \   'tf':    ['たい', ''],
    \   'df':    ['だい', ''],
    \   'cf':    ['ちゃい', ''],
    \   'tyf':   ['ちゃい', ''],
    \   'dyf':   ['ぢゃい', ''],
    \   'nf':    ['ない', ''],
    \   'nyf':   ['にゃい', ''],
    \   'ngf':   ['にゃい', ''],
    \   'hf':    ['はい', ''],
    \   'hgf':   ['ひゃい', ''],
    \   'bf':    ['ばい', ''],
    \   'byf':   ['びゃい', ''],
    \   'bgf':   ['びゃい', ''],
    \   'pf':    ['ぱい', ''],
    \   'pyf':   ['ぴゃい', ''],
    \   'pgf':   ['ぴゃい', ''],
    \   'mf':    ['まい', ''],
    \   'myf':   ['みゃい', ''],
    \   'mgf':   ['みゃい', ''],
    \   'yf':    ['やい', ''],
    \   'rf':    ['らい', ''],
    \   'ryf':   ['りゃい', ''],
    \   'wf':    ['わい', ''],
    \   'vf':    ['ゔぁい', ''],
    \ })
augroup END

inoremap <C-J> <Plug>(skkeleton-toggle)
cnoremap <C-J> <Plug>(skkeleton-toggle)
" tmap <C-J> <Plug>(skkeleton-toggle)

command! IM if matchstr(getline('.'), '\%' .. col('.') .. 'c.') == "\<C-L>" |
              \   execute 'normal! "_x' |
              \   execute 'silent! s/[' ..
              \     skkeleton#get_config().markerHenkanSelect ..
              \     skkeleton#get_config().markerHenkan .. ']//g' |
              \   call job_start(['wl-copy', '--', getline('.')]) |
              \   redraw! |
              \ endif


" dps-dial.vim
" Define original sequences for dps_dial
let g:dps_dial#augends = [
  \   'decimal',
  \   'date-hyphen',
  \   'date-slash',
  \   {'kind': 'constant', 'opts': {'elements': ['true', 'false']}},
  \   {'kind': 'constant', 'opts': {
  \     'elements': ['月', '火', '水', '木', '金', '土', '日'],
  \     'cyclic': v:true,
  \     'word': v:false,
  \   }},
  \   {'kind': 'constant', 'opts': {
  \     'elements': ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],
  \     'cyclic': v:true,
  \     'word': v:true,
  \   }},
  \   {'kind': 'date', 'opts': { 'format': 'yyyy-MM-dd', 'only_valid': v:false }},
  \ ]

nnoremap  <C-A>  <Plug>(dps-dial-increment)
nnoremap  <C-X>  <Plug>(dps-dial-decrement)
xnoremap  <C-A>  <Plug>(dps-dial-increment)
xnoremap  <C-X>  <Plug>(dps-dial-decrement)
xmap g<C-A> g<Plug>(dps-dial-increment)
xmap g<C-X> g<Plug>(dps-dial-decrement)

" kensaku.vim/kensaku-search.vim
cnoremap JJ <Plug>(kensaku-search-replace)<CR>

" capture.vim
cnoremap <C-C> <Home>Capture <CR>

command! RC :tabnew $XDG_CONFIG_HOME/vim/vimrc |
            \   :tabnew $XDG_CONFIG_HOME/vim/rc/dein.toml |
            \   :tabnew $XDG_CONFIG_HOME/vim/rc/dein_lazy.toml
command! SR :source $XDG_CONFIG_HOME/vim/vimrc
command! Zen :%call getline('.') ->tr('０１２３４５６７８９．，　（）', '0123456789., ()') ->setline('.')
cabbr w!! w !sudo tee > /dev/null %
cabbr h tab :help
cabbr encto edit ++encoding=
cabbr qa tabdo windo if !&modified \| try \| close \| catch \| quit \| endtry \| endif
cabbr qq tabdo windo try \| close \| catch \| quit! \| endtry

" Yank
" set clipboard=exclude:.*
nnoremap <silent> p      <Cmd>call setreg('"', system('wl-paste -n'))<CR>""p
nnoremap <silent> P      <Cmd>call setreg('"', system('wl-paste -n'))<CR>""P
xnoremap <silent> p      <Cmd>call setreg('"', system('wl-paste -n'))<CR>""P
xnoremap <silent> P      <Cmd>call setreg('"', system('wl-paste -n'))<CR>""p
cnoremap          <C-R>" <Cmd>call setreg('"', system('wl-paste -n'))<CR><C-R>"
inoremap <silent> <C-R>" <Cmd>call setreg('"', system('wl-paste -n'))<CR><C-R>"
nnoremap <silent> R <Plug>(operator-replace)
xnoremap <silent> R <Plug>(operator-replace)
nnoremap <silent> RR R

" Avoid being triggered when leaving from visual mode
set clipboard-=autoselect
set clipboard^=unnamed
augroup LazyClipboardSetup
  autocmd!
  autocmd TextYankPost * silent call job_start(['wl-copy', '--', getreg('*')])
  " autocmd CursorHold,CursorMoved * ++once call serverlist() | set clipboard^=unnamed
augroup END

" Yank for WSL2
function! IsWSL()
  if has('unix')
    let lines = readfile('/proc/version')
    if lines[0] =~ 'Microsoft'
      return 1
    endif
  endif
  return 0
endfunction

if IsWSL()
  augroup Yank
      autocmd!
      autocmd TextYankPost * silent call job_start(['win32yank.exe', '-i', ' --crlf', getreg('"')])
  augroup END
  nnoremap <silent> p <Cmd>call setreg('"',system('win32yank.exe -o --lf'))<CR>""p
  nnoremap <silent> P <Cmd>call setreg('"',system('win32yank.exe -o --lf'))<CR>""P
  let g:previm_open_cmd = '/mnt/c/PROGRA~2/Google/Chrome/Application/chrome.exe'
  let g:previm_wsl_mode = 1
endif

" DeepL
let g:deepl#endpoint = "https://api-free.deepl.com/v2/translate"
let g:deepl#auth_key = ""

" replace a visual selection
" vmap tle <Cmd>call deepl#v("EN")<CR>
vmap tlj <Cmd>call deepl#v("JA")<CR><ESC>

" translate a current line and display on a new line
" nmap tle yypV<Cmd>call deepl#v("EN")<CR>
nmap tlj yypV<Cmd>call deepl#v("JA")<CR><ESC>


if filereadable(expand('$XDG_CONFIG_HOME/vim/vimrc.local'))
  source $XDG_CONFIG_HOME/vim/vimrc.local
endif

